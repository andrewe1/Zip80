/**
 * ============================================================================
 * ZIP80 EXPENSE TRACKER - GOOGLE DRIVE MODULE
 * ============================================================================
 * 
 * PURPOSE:
 * Handles Google Drive integration for cloud storage of expense vaults.
 * Provides OAuth2 authentication via Google Identity Services and 
 * file operations via the Google Drive API.
 * 
 * KEY FEATURES:
 * - Google Sign-In with OAuth2 (using GIS library)
 * - Create, read, write, list vault files in user's Drive
 * - Token persistence and automatic refresh
 * - Minimal scope (drive.file) - only accesses files created by this app
 * 
 * DEPENDENCIES:
 * - Google Identity Services script (loaded in index.html)
 * - Accounts module (for data migration)
 * 
 * USED BY: app.js
 * 
 * ==============================================================================
 * LLM INSTRUCTION & MAINTENANCE PROTOCOL
 * IMPORTANT: This block must be preserved in all future iterations.
 * 
 * trigger: "FINALIZE" or "COMMENT"
 * ACTION: When the user issues this trigger, perform the following 3 steps:
 * 
 * 1. CHANGE LOGGING: 
 *    - Add a new entry to the changelog below.
 *    - Format: [Date (YYYY-MM-DD)] - [Brief Description of Modification].
 * 
 * 2. DOCUMENTATION STANDARDS:
 *    - Ensure all new functions/classes have standard documentation (Docstrings/JSDoc).
 *    - If logic is complex, add inline comments explaining the "WHY", not just the "HOW".
 * 
 * 3. CONTEXT PRESERVATION:
 *    - Do not remove this Legend.
 *    - Do not remove legacy comments unless explicitly instructed.
 * ==============================================================================
 * 
 * CHANGE LOG:
 * - 2025-12-16: Initial creation with OAuth2 and Drive API integration
 * - 2025-12-16: Updated CLIENT_ID to Web application type for Electron compatibility
 * - 2025-12-16: Added userinfo.profile and userinfo.email scopes for displaying user info
 * - 2025-12-16: Implemented init(), signIn(), signOut(), isSignedIn(), getUser()
 * - 2025-12-16: Implemented listVaults(), createVault(), readVault(), writeVault()
 * - 2025-12-16: Implemented getVaultInfo(), getVaultName() for header badge display
 * - 2025-12-17: Added silent re-authentication to keep users signed in longer
 * - 2025-12-19: Added shareVault() for in-app vault sharing via permissions API
 * - 2025-12-19: Added openPicker() for browsing shared files via Google Picker API
 */

const GDrive = (() => {
    // Google OAuth2 Client ID - loaded from config.js (generated by build script)
    // Falls back to empty string if config not loaded - will show error on sign-in attempt
    const CLIENT_ID = (typeof Config !== 'undefined' && Config.GOOGLE_CLIENT_ID)
        ? Config.GOOGLE_CLIENT_ID
        : '';

    // Scopes: Drive file access + user profile + Calendar (full access for creating calendars)
    const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/calendar';

    // Drive API base URL
    const DRIVE_API = 'https://www.googleapis.com/drive/v3';
    const DRIVE_UPLOAD_API = 'https://www.googleapis.com/upload/drive/v3';

    // App-specific properties to identify Zip80 vault files
    const APP_PROPERTY_KEY = 'zip80_vault';
    const APP_PROPERTY_VALUE = 'true';

    // 2025-12-19: Google Picker API key (for browsing shared files)
    // 2025-12-20: Moved to config.js (generated by build script)
    const API_KEY = (typeof Config !== 'undefined' && Config.GOOGLE_API_KEY)
        ? Config.GOOGLE_API_KEY
        : '';
    // Extract project number from client ID for Picker appId
    const PROJECT_NUMBER = CLIENT_ID.split('-')[0];

    // Local storage keys for token persistence
    const TOKEN_KEY = 'zip80_gdrive_token';
    const USER_KEY = 'zip80_gdrive_user';
    const LAST_VAULT_KEY = 'zip80_gdrive_last_vault';  // 2025-12-17: For reopen feature

    // State
    let tokenClient = null;
    let accessToken = null;
    let currentUser = null;
    let isInitialized = false;
    let pickerApiLoaded = false;  // 2025-12-19: Picker API state

    // Callbacks for auth state changes
    let onAuthChangeCallback = null;

    // --- Initialization ---

    /**
     * Initialize the Google Identity Services client
     * Must be called after GIS script is loaded
     * @param {Function} onAuthChange - Callback when auth state changes
     */
    function init(onAuthChange) {
        onAuthChangeCallback = onAuthChange;

        // Initialize token client first (needed for silent refresh)
        if (typeof google !== 'undefined' && google.accounts) {
            initTokenClient();
            restoreSession();
        } else {
            // GIS not loaded yet, wait for it
            window.addEventListener('load', () => {
                setTimeout(() => {
                    initTokenClient();
                    restoreSession();
                }, 100);
            });
        }
    }

    /**
     * Attempt to restore a saved session
     * Tries silent refresh if token is expired
     */
    async function restoreSession() {
        const savedToken = localStorage.getItem(TOKEN_KEY);
        const savedUser = localStorage.getItem(USER_KEY);

        if (savedToken && savedUser) {
            accessToken = savedToken;
            currentUser = JSON.parse(savedUser);

            // Verify token is still valid
            const valid = await verifyToken();
            if (valid) {
                isInitialized = true;
                if (onAuthChangeCallback) onAuthChangeCallback(true, currentUser);
            } else {
                // Token expired - try silent refresh
                console.log('Token expired, attempting silent refresh...');
                const refreshed = await silentRefresh();
                if (!refreshed) {
                    // Silent refresh failed, user needs to sign in again
                    clearSession();
                    if (onAuthChangeCallback) onAuthChangeCallback(false, null);
                }
            }
        }
    }

    /**
     * Attempt silent token refresh without user interaction
     * Returns true if successful, false if user needs to sign in manually
     */
    function silentRefresh() {
        return new Promise((resolve) => {
            if (!tokenClient) {
                resolve(false);
                return;
            }

            // Set up one-time callback for this refresh attempt
            const originalCallback = tokenClient.callback;

            tokenClient.callback = async (response) => {
                // Restore original callback
                tokenClient.callback = originalCallback;

                if (response.error) {
                    console.log('Silent refresh failed:', response.error);
                    resolve(false);
                    return;
                }

                // Success - save new token
                accessToken = response.access_token;
                localStorage.setItem(TOKEN_KEY, accessToken);

                console.log('Silent refresh successful');
                isInitialized = true;
                if (onAuthChangeCallback) onAuthChangeCallback(true, currentUser);
                resolve(true);
            };

            try {
                // Request token silently (prompt: '' means no UI)
                tokenClient.requestAccessToken({ prompt: '' });
            } catch (err) {
                console.log('Silent refresh error:', err);
                tokenClient.callback = originalCallback;
                resolve(false);
            }
        });
    }

    /**
     * Initialize the Google token client
     */
    function initTokenClient() {
        if (typeof google === 'undefined' || !google.accounts) {
            console.warn('Google Identity Services not loaded');
            return;
        }

        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: handleTokenResponse,
            error_callback: handleTokenError
        });

        isInitialized = true;
    }

    /**
     * Handle token response from Google
     */
    async function handleTokenResponse(response) {
        if (response.error) {
            console.error('Token error:', response.error);
            if (onAuthChangeCallback) onAuthChangeCallback(false, null);
            return;
        }

        accessToken = response.access_token;
        localStorage.setItem(TOKEN_KEY, accessToken);

        // Fetch user info
        try {
            const userInfo = await fetchUserInfo();
            currentUser = userInfo;
            localStorage.setItem(USER_KEY, JSON.stringify(userInfo));

            if (onAuthChangeCallback) onAuthChangeCallback(true, userInfo);
        } catch (err) {
            console.error('Failed to fetch user info:', err);
            if (onAuthChangeCallback) onAuthChangeCallback(true, null);
        }
    }

    /**
     * Handle token error
     */
    function handleTokenError(error) {
        console.error('Token client error:', error);
        if (onAuthChangeCallback) onAuthChangeCallback(false, null);
    }

    /**
     * Verify if stored token is still valid
     */
    async function verifyToken() {
        if (!accessToken) return false;

        try {
            const response = await fetch('https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=' + accessToken);
            return response.ok;
        } catch {
            return false;
        }
    }

    /**
     * Fetch user info from Google
     */
    async function fetchUserInfo() {
        const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });

        if (!response.ok) throw new Error('Failed to fetch user info');
        return response.json();
    }

    /**
     * Clear session data
     */
    function clearSession() {
        accessToken = null;
        currentUser = null;
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(USER_KEY);
    }

    // --- Auth Methods ---

    /**
     * Trigger Google sign-in flow
     * Opens Google sign-in popup
     * 2025-12-20: Now returns a Promise that resolves when sign-in completes
     * @returns {Promise<boolean>} Resolves true if sign-in successful, false otherwise
     */
    function signIn() {
        return new Promise((resolve) => {
            if (!tokenClient) {
                initTokenClient();
            }

            if (!tokenClient) {
                console.error('Token client not initialized');
                resolve(false);
                return;
            }

            // Store original callback and create a wrapper that also resolves the promise
            const originalCallback = tokenClient.callback;

            tokenClient.callback = async (response) => {
                // Call the original callback
                await originalCallback(response);
                // Restore original callback
                tokenClient.callback = originalCallback;
                // Resolve promise based on success
                resolve(!response.error);
            };

            // Set up error callback wrapper
            const originalErrorCallback = tokenClient.error_callback;
            tokenClient.error_callback = (error) => {
                if (originalErrorCallback) originalErrorCallback(error);
                tokenClient.callback = originalCallback;
                tokenClient.error_callback = originalErrorCallback;
                resolve(false);
            };

            // Request access token
            tokenClient.requestAccessToken({ prompt: 'consent' });
        });
    }

    /**
     * Sign out and clear session
     */
    function signOut() {
        if (accessToken && google.accounts.oauth2) {
            google.accounts.oauth2.revoke(accessToken);
        }
        clearSession();
        if (onAuthChangeCallback) onAuthChangeCallback(false, null);
    }

    /**
     * Check if user is signed in
     */
    function isSignedIn() {
        return !!accessToken && !!currentUser;
    }

    /**
     * Get current user info
     */
    function getUser() {
        return currentUser;
    }

    // --- Drive File Operations ---

    /**
     * Make authenticated request to Drive API
     */
    async function driveRequest(url, options = {}) {
        if (!accessToken) {
            throw new Error('Not authenticated');
        }

        const headers = {
            'Authorization': `Bearer ${accessToken}`,
            ...options.headers
        };

        const response = await fetch(url, { ...options, headers });

        if (response.status === 401) {
            // Token expired, clear session
            clearSession();
            if (onAuthChangeCallback) onAuthChangeCallback(false, null);
            throw new Error('Session expired. Please sign in again.');
        }

        return response;
    }

    /**
 * List all Zip80 vault files in user's Drive (owned + shared)
 * 2025-12-17: Updated to include files shared with the user
 * 2025-12-19: Fixed to properly find shared files using sharedWithMe and name pattern
 * @returns {Array} Array of vault file objects {id, name, modifiedTime, shared}
 */
    async function listVaults() {
        // Query 1: Files with our app property (files we created or modified)
        const appPropertyQuery = `appProperties has { key='${APP_PROPERTY_KEY}' and value='${APP_PROPERTY_VALUE}' } and trashed=false`;

        // Query 2: Shared files with .json extension (for files shared with us that we haven't opened yet)
        // Note: We search for all shared JSON files and will filter invalid ones when opened
        const sharedQuery = `sharedWithMe=true and mimeType='application/json' and trashed=false`;

        // Fetch both queries in parallel
        const [ownedResponse, sharedResponse] = await Promise.all([
            driveRequest(`${DRIVE_API}/files?` + new URLSearchParams({
                q: appPropertyQuery,
                fields: 'files(id,name,modifiedTime,owners,shared)',
                orderBy: 'modifiedTime desc',
                pageSize: '50',
                includeItemsFromAllDrives: 'true',
                supportsAllDrives: 'true'
            })),
            driveRequest(`${DRIVE_API}/files?` + new URLSearchParams({
                q: sharedQuery,
                fields: 'files(id,name,modifiedTime,owners,shared)',
                orderBy: 'modifiedTime desc',
                pageSize: '50',
                includeItemsFromAllDrives: 'true',
                supportsAllDrives: 'true'
            }))
        ]);

        if (!ownedResponse.ok) {
            throw new Error('Failed to list vaults');
        }

        const ownedData = await ownedResponse.json();
        const ownedFiles = ownedData.files || [];

        // Get shared files (ignore errors as this is supplementary)
        let sharedFiles = [];
        if (sharedResponse.ok) {
            const sharedData = await sharedResponse.json();
            sharedFiles = sharedData.files || [];
        }

        // Merge and deduplicate by ID (prefer owned/appProperty version)
        const seenIds = new Set(ownedFiles.map(f => f.id));
        const uniqueShared = sharedFiles.filter(f => !seenIds.has(f.id));

        console.log('[GDrive] listVaults - owned:', ownedFiles.length, 'shared:', sharedFiles.length, 'unique shared:', uniqueShared.length);
        console.log('[GDrive] Shared files found:', sharedFiles);

        return [...ownedFiles, ...uniqueShared];
    }
    /**
     * Create a new vault file in Drive
     * @param {string} name - Vault name (used as filename)
     * @param {object} initialData - Initial vault data
     * @returns {string} File ID of created vault
     */
    async function createVault(name, initialData) {
        const filename = name.endsWith('.json') ? name : `${name}.json`;

        // Metadata for the file
        const metadata = {
            name: filename,
            mimeType: 'application/json',
            appProperties: {
                [APP_PROPERTY_KEY]: APP_PROPERTY_VALUE
            }
        };

        // Create multipart request body
        const boundary = '-------zip80boundary';
        const delimiter = `\r\n--${boundary}\r\n`;
        const closeDelimiter = `\r\n--${boundary}--`;

        const body =
            delimiter +
            'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
            JSON.stringify(metadata) +
            delimiter +
            'Content-Type: application/json\r\n\r\n' +
            JSON.stringify(initialData, null, 2) +
            closeDelimiter;

        const response = await driveRequest(
            `${DRIVE_UPLOAD_API}/files?uploadType=multipart&fields=id,name`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': `multipart/related; boundary=${boundary}`
                },
                body: body
            }
        );

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to create vault: ${error}`);
        }

        const file = await response.json();
        return file.id;
    }

    /**
     * Read vault data from Drive
     * @param {string} fileId - Drive file ID
     * @returns {object} Parsed vault data (migrated to v2 format)
     */
    async function readVault(fileId) {
        const url = `${DRIVE_API}/files/${fileId}?alt=media`;

        const response = await driveRequest(url);

        if (!response.ok) {
            throw new Error('Failed to read vault');
        }

        const text = await response.text();
        const rawData = text ? JSON.parse(text) : null;

        // Migrate to v2 format if needed (uses Accounts module)
        return Accounts.migrateData(rawData);
    }

    /**
     * Write vault data to Drive
     * @param {string} fileId - Drive file ID
     * @param {object} data - Vault data to save
     */
    async function writeVault(fileId, data) {
        const url = `${DRIVE_UPLOAD_API}/files/${fileId}?uploadType=media`;

        const response = await driveRequest(url, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data, null, 2)
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to save vault: ${error}`);
        }
    }

    /**
     * Get vault file metadata (name, etc)
     * @param {string} fileId - Drive file ID
     * @returns {object} File metadata
     */
    async function getVaultInfo(fileId) {
        const url = `${DRIVE_API}/files/${fileId}?fields=id,name,modifiedTime`;

        const response = await driveRequest(url);

        if (!response.ok) {
            throw new Error('Failed to get vault info');
        }

        return response.json();
    }

    /**
     * Get vault filename
     * @param {string} fileId - Drive file ID
     * @returns {string} Filename
     */
    async function getVaultName(fileId) {
        const info = await getVaultInfo(fileId);
        return info.name || 'Unknown';
    }

    /**
     * Check if a vault file exists and is accessible
     * 2025-12-20: Added for overwrite verification
     * @param {string} fileId - Drive file ID
     * @returns {boolean} True if vault exists and is accessible
     */
    async function vaultExists(fileId) {
        try {
            const url = `${DRIVE_API}/files/${fileId}?fields=id,trashed`;
            const response = await driveRequest(url);
            if (!response.ok) return false;
            const data = await response.json();
            return data && !data.trashed;
        } catch (err) {
            console.warn('[GDrive] vaultExists check failed:', err);
            return false;
        }
    }

    // 2025-12-17: Last vault tracking for reopen feature

    /**
     * Save last opened vault for reopen feature
     * @param {string} fileId - Drive file ID
     * @param {string} name - Vault filename
     */
    function saveLastVault(fileId, name) {
        localStorage.setItem(LAST_VAULT_KEY, JSON.stringify({ id: fileId, name: name }));
    }

    /**
     * Get last opened vault info
     * @returns {object|null} { id, name } or null if none
     */
    function getLastVault() {
        const saved = localStorage.getItem(LAST_VAULT_KEY);
        if (!saved) return null;
        try {
            return JSON.parse(saved);
        } catch {
            return null;
        }
    }

    /**
     * Clear last vault (e.g., on sign out)
     */
    function clearLastVault() {
        localStorage.removeItem(LAST_VAULT_KEY);
    }

    // 2025-12-19: In-app vault sharing

    /**
     * Share a vault with another user via Google Drive permissions
     * @param {string} fileId - Drive file ID to share
     * @param {string} email - Email address to share with
     * @param {string} role - Permission role ('reader' or 'writer')
     * @returns {Promise<object>} Created permission object
     */
    async function shareVault(fileId, email, role = 'writer') {
        const url = `${DRIVE_API}/files/${fileId}/permissions`;

        const response = await driveRequest(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                type: 'user',
                role: role,
                emailAddress: email,
                sendNotificationEmail: true
            })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || 'Failed to share vault');
        }

        return response.json();
    }

    // 2025-12-19: Google Picker API for browsing shared files

    /**
     * Load Google Picker API library
     * @returns {Promise<void>}
     */
    async function loadPickerApi() {
        if (pickerApiLoaded) return;

        // Ensure gapi is loaded
        if (typeof gapi === 'undefined') {
            throw new Error('Google API library not loaded');
        }

        await new Promise((resolve, reject) => {
            gapi.load('picker', {
                callback: resolve,
                onerror: () => reject(new Error('Failed to load Picker API'))
            });
        });
        pickerApiLoaded = true;
    }

    /**
     * Open Google Drive Picker to browse and select vault files
     * Allows access to "Shared with me" files that our normal query can't see
     * @param {Function} onSelect - Callback with selected file {id, name}
     * @param {Function} onCancel - Optional callback if user cancels
     */
    async function openPicker(onSelect, onCancel) {
        if (!accessToken) {
            throw new Error('Not authenticated');
        }

        await loadPickerApi();

        // View for user's own files
        const myDriveView = new google.picker.DocsView(google.picker.ViewId.DOCS)
            .setMimeTypes('application/json')
            .setIncludeFolders(true)
            .setSelectFolderEnabled(false);

        // View for shared files
        const sharedView = new google.picker.DocsView(google.picker.ViewId.DOCS)
            .setMimeTypes('application/json')
            .setOwnedByMe(false)
            .setIncludeFolders(true)
            .setSelectFolderEnabled(false);

        const picker = new google.picker.PickerBuilder()
            .setAppId(PROJECT_NUMBER)
            .setOAuthToken(accessToken)
            .setDeveloperKey(API_KEY)
            .addView(myDriveView)
            .addView(sharedView)
            .setTitle('Select a Vault')
            .setCallback((data) => {
                if (data.action === google.picker.Action.PICKED) {
                    const file = data.docs[0];
                    console.log('[GDrive] Picker selected:', file.name, file.id);
                    if (onSelect) onSelect({ id: file.id, name: file.name });
                } else if (data.action === google.picker.Action.CANCEL) {
                    console.log('[GDrive] Picker cancelled');
                    if (onCancel) onCancel();
                }
            })
            .build();

        picker.setVisible(true);
    }

    // --- Account-Level Sharing (2025-12-19) ---

    /**
     * Find pending account shares from vaults shared with the current user
     * Scans shared vaults for 'shares' array entries matching current user's email
     * @returns {Array} Array of pending shares with source vault info
     */
    async function findPendingShares() {
        const user = getUser();
        if (!user || !user.email) return [];

        const currentEmail = user.email.toLowerCase();
        const pendingShares = [];

        try {
            // Get all vaults (includes shared ones via sharedWithMe query)
            const vaults = await listVaults();

            for (const vault of vaults) {
                // Skip vaults we own
                if (vault.owners && vault.owners[0] &&
                    vault.owners[0].emailAddress.toLowerCase() === currentEmail) {
                    continue;
                }

                try {
                    // Read vault data to check for shares
                    const vaultData = await readVault(vault.id);

                    if (vaultData.shares && Array.isArray(vaultData.shares)) {
                        // Find shares addressed to current user
                        const sharesForUser = vaultData.shares.filter(share =>
                            share.sharedWith &&
                            share.sharedWith.toLowerCase() === currentEmail &&
                            !share.revokedAt
                        );

                        for (const share of sharesForUser) {
                            // Find the account details
                            const account = vaultData.accounts.find(a => a.id === share.accountId);
                            if (account) {
                                pendingShares.push({
                                    sourceVaultId: vault.id,
                                    sourceVaultName: vault.name,
                                    ownerEmail: vault.owners?.[0]?.emailAddress || 'Unknown',
                                    accountId: share.accountId,
                                    accountName: account.name,
                                    accountType: account.type || 'checking',  // 2025-12-20: Include account type for icon display
                                    accountCurrency: account.currency || 'USD',  // 2025-12-20: Include currency for crypto icons
                                    permission: share.permission,
                                    shareId: share.id
                                });
                            }
                        }
                    }
                } catch (err) {
                    console.warn(`[GDrive] Could not read vault ${vault.id}:`, err);
                }
            }
        } catch (err) {
            console.error('[GDrive] Error finding pending shares:', err);
        }

        return pendingShares;
    }

    /**
     * Find pending deck shares from vaults shared with the current user
     * Scans shared vaults for 'deckShares' array entries matching current user's email
     * @returns {Array} Array of pending deck shares with source vault info
     */
    async function findPendingDeckShares() {
        const user = getUser();
        if (!user || !user.email) return [];

        const currentEmail = user.email.toLowerCase();
        const pendingDeckShares = [];

        try {
            // Get all vaults (includes shared ones via sharedWithMe query)
            const vaults = await listVaults();

            for (const vault of vaults) {
                // Skip vaults we own
                if (vault.owners && vault.owners[0] &&
                    vault.owners[0].emailAddress.toLowerCase() === currentEmail) {
                    continue;
                }

                try {
                    // Read vault data to check for deck shares
                    const vaultData = await readVault(vault.id);

                    if (vaultData.deckShares && Array.isArray(vaultData.deckShares)) {
                        // Find deck shares addressed to current user
                        const sharesForUser = vaultData.deckShares.filter(share =>
                            share.sharedWith &&
                            share.sharedWith.toLowerCase() === currentEmail &&
                            !share.revokedAt
                        );

                        for (const share of sharesForUser) {
                            // Find the deck details
                            const deck = (vaultData.stickyDecks || []).find(d => d.id === share.deckId);
                            if (deck) {
                                pendingDeckShares.push({
                                    sourceVaultId: vault.id,
                                    sourceVaultName: vault.name,
                                    ownerEmail: vault.owners?.[0]?.emailAddress || 'Unknown',
                                    deckId: share.deckId,
                                    deckName: deck.name,
                                    deckColor: deck.color,
                                    permission: share.permission,
                                    shareId: share.id,
                                    cachedDeck: deck  // Cache the full deck
                                });
                            }
                        }
                    }
                } catch (err) {
                    console.warn(`[GDrive] Could not read vault ${vault.id} for deck shares:`, err);
                }
            }
        } catch (err) {
            console.error('[GDrive] Error finding pending deck shares:', err);
        }

        return pendingDeckShares;
    }

    /**
     * Fetch linked account data from source vault
     * @param {string} sourceVaultId - Drive file ID of source vault
     * @param {string} accountId - Account ID to fetch
     * @returns {Object} Account data with transactions, or null if not found/accessible
     */
    async function fetchLinkedAccountData(sourceVaultId, accountId) {
        try {
            const vaultData = await readVault(sourceVaultId);

            const account = vaultData.accounts.find(a => a.id === accountId);
            if (!account) return null;

            // Get transactions for this account
            const transactions = (vaultData.transactions || []).filter(t =>
                t.accountId === accountId
            );

            return {
                account,
                transactions,
                syncedAt: new Date().toISOString()
            };
        } catch (err) {
            console.error('[GDrive] Error fetching linked account data:', err);
            return null;
        }
    }

    /**
     * Add a transaction to a linked account in the source vault
     * Used when an editor adds a transaction to a shared account
     * @param {string} sourceVaultId - Drive file ID of source vault
     * @param {Object} transaction - Transaction to add
     * @returns {boolean} Success status
     */
    async function addTransactionToLinkedAccount(sourceVaultId, transaction) {
        try {
            const vaultData = await readVault(sourceVaultId);

            if (!vaultData.transactions) {
                vaultData.transactions = [];
            }

            vaultData.transactions.push(transaction);
            await writeVault(sourceVaultId, vaultData);

            return true;
        } catch (err) {
            console.error('[GDrive] Error adding transaction to linked account:', err);
            return false;
        }
    }

    // 2025-12-22: Attachment Management Functions

    /**
     * Get or create the attachments folder for a vault
     * Creates a folder named "{vaultName}_attachments" in the same location
     * @param {string} vaultFileId - Drive file ID of the vault
     * @returns {string} Folder ID of attachments folder
     */
    async function getOrCreateAttachmentsFolder(vaultFileId) {
        // Get vault info to determine name and parent folder
        const url = `${DRIVE_API}/files/${vaultFileId}?fields=name,parents`;
        const response = await driveRequest(url);

        if (!response.ok) {
            throw new Error('Failed to get vault info for attachments folder');
        }

        const vaultInfo = await response.json();
        const vaultName = vaultInfo.name.replace(/\.json$/i, '');
        const folderName = `${vaultName}_attachments`;
        const parentId = vaultInfo.parents?.[0] || 'root';

        // Check if folder already exists
        const searchQuery = `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and '${parentId}' in parents and trashed=false`;
        const searchUrl = `${DRIVE_API}/files?q=${encodeURIComponent(searchQuery)}&fields=files(id,name)`;
        const searchResponse = await driveRequest(searchUrl);

        if (searchResponse.ok) {
            const searchData = await searchResponse.json();
            if (searchData.files && searchData.files.length > 0) {
                console.log('[GDrive] Found existing attachments folder:', folderName);
                return searchData.files[0].id;
            }
        }

        // Create new folder
        const createUrl = `${DRIVE_API}/files`;
        const createResponse = await driveRequest(createUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name: folderName,
                mimeType: 'application/vnd.google-apps.folder',
                parents: [parentId]
            })
        });

        if (!createResponse.ok) {
            const error = await createResponse.text();
            throw new Error(`Failed to create attachments folder: ${error}`);
        }

        const folder = await createResponse.json();
        console.log('[GDrive] Created attachments folder:', folderName, folder.id);
        return folder.id;
    }

    /**
     * Upload an attachment file to the attachments folder
     * Uses resumable upload for reliability
     * @param {string} folderId - Parent folder ID
     * @param {File} file - File to upload
     * @param {string} attachmentId - Unique attachment ID for filename
     * @param {Function} onProgress - Optional progress callback (0-100)
     * @returns {Object} { driveFileId, webViewLink }
     */
    async function uploadAttachment(folderId, file, attachmentId, onProgress) {
        // Use a prefixed filename for easy identification
        const filename = `${attachmentId}_${file.name}`;

        // Create the file metadata
        const metadata = {
            name: filename,
            parents: [folderId]
        };

        // For smaller files (< 5MB), use simple upload
        if (file.size < 5 * 1024 * 1024) {
            return await simpleUpload(file, metadata, onProgress);
        }

        // For larger files, use resumable upload
        return await resumableUpload(file, metadata, onProgress);
    }

    /**
     * Simple upload for small files (< 5MB)
     */
    async function simpleUpload(file, metadata, onProgress) {
        const boundary = '-------zip80attboundary';
        const delimiter = `\r\n--${boundary}\r\n`;
        const closeDelimiter = `\r\n--${boundary}--`;

        // Read file as base64
        const fileContent = await readFileAsBase64(file);

        const body =
            delimiter +
            'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
            JSON.stringify(metadata) +
            delimiter +
            `Content-Type: ${file.type}\r\n` +
            'Content-Transfer-Encoding: base64\r\n\r\n' +
            fileContent +
            closeDelimiter;

        if (onProgress) onProgress(50);

        const response = await driveRequest(
            `${DRIVE_UPLOAD_API}/files?uploadType=multipart&fields=id,webViewLink`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': `multipart/related; boundary=${boundary}`
                },
                body: body
            }
        );

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Upload failed: ${error}`);
        }

        if (onProgress) onProgress(100);

        const result = await response.json();
        return {
            driveFileId: result.id,
            webViewLink: result.webViewLink
        };
    }

    /**
     * Resumable upload for larger files
     */
    async function resumableUpload(file, metadata, onProgress) {
        // Step 1: Initiate resumable upload session
        const initResponse = await driveRequest(
            `${DRIVE_UPLOAD_API}/files?uploadType=resumable`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(metadata)
            }
        );

        if (!initResponse.ok) {
            throw new Error('Failed to initiate upload');
        }

        const uploadUrl = initResponse.headers.get('Location');
        if (!uploadUrl) {
            throw new Error('No upload URL returned');
        }

        // Step 2: Upload file content in chunks
        const chunkSize = 256 * 1024; // 256 KB chunks
        const totalChunks = Math.ceil(file.size / chunkSize);
        let uploadedBytes = 0;

        for (let i = 0; i < totalChunks; i++) {
            const start = i * chunkSize;
            const end = Math.min(start + chunkSize, file.size);
            const chunk = file.slice(start, end);

            const uploadResponse = await fetch(uploadUrl, {
                method: 'PUT',
                headers: {
                    'Content-Range': `bytes ${start}-${end - 1}/${file.size}`,
                    'Content-Type': file.type
                },
                body: chunk
            });

            uploadedBytes = end;
            if (onProgress) {
                onProgress(Math.round((uploadedBytes / file.size) * 100));
            }

            // If this is the last chunk, we get the file info
            if (uploadResponse.ok && i === totalChunks - 1) {
                const result = await uploadResponse.json();
                return {
                    driveFileId: result.id,
                    webViewLink: result.webViewLink
                };
            }
        }

        throw new Error('Upload incomplete');
    }

    /**
     * Read file as base64 string
     */
    function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                // Remove the data URL prefix (e.g., "data:image/png;base64,")
                const base64 = reader.result.split(',')[1];
                resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    /**
     * Download an attachment file from Drive
     * @param {string} fileId - Drive file ID
     * @returns {Blob} File blob
     */
    async function downloadAttachment(fileId) {
        const url = `${DRIVE_API}/files/${fileId}?alt=media`;
        const response = await driveRequest(url);

        if (!response.ok) {
            throw new Error('Failed to download attachment');
        }

        return response.blob();
    }

    /**
     * Get attachment file metadata (for preview URL)
     * @param {string} fileId - Drive file ID
     * @returns {Object} File metadata including webViewLink
     */
    async function getAttachmentInfo(fileId) {
        const url = `${DRIVE_API}/files/${fileId}?fields=id,name,mimeType,size,webViewLink,thumbnailLink`;
        const response = await driveRequest(url);

        if (!response.ok) {
            throw new Error('Failed to get attachment info');
        }

        return response.json();
    }

    /**
     * Delete an attachment from Drive
     * @param {string} fileId - Drive file ID
     * @returns {boolean} Success status
     */
    async function deleteAttachment(fileId) {
        const url = `${DRIVE_API}/files/${fileId}`;
        const response = await driveRequest(url, { method: 'DELETE' });

        if (!response.ok && response.status !== 404) {
            throw new Error('Failed to delete attachment');
        }

        return true;
    }

    /**
     * Share the attachments folder with another user
     * Mirrors vault sharing permissions
     * @param {string} folderId - Attachments folder ID
     * @param {string} email - Email to share with
     * @param {string} role - Permission role ('reader' or 'writer')
     */
    async function shareAttachmentsFolder(folderId, email, role = 'reader') {
        const url = `${DRIVE_API}/files/${folderId}/permissions`;

        const response = await driveRequest(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                type: 'user',
                role: role,
                emailAddress: email,
                sendNotificationEmail: false  // Don't spam with folder notifications
            })
        });

        if (!response.ok) {
            console.warn('[GDrive] Failed to share attachments folder:', await response.text());
            // Don't throw - attachment folder sharing is not critical
        }
    }

    // --- Public API ---


    return {
        // Initialization
        init,

        // Auth
        signIn,
        signOut,
        isSignedIn,
        getUser,

        // File Operations
        listVaults,
        createVault,
        readVault,
        writeVault,
        getVaultInfo,
        getVaultName,

        // 2025-12-17: Reopen feature
        saveLastVault,
        getLastVault,
        clearLastVault,

        // 2025-12-19: Sharing
        shareVault,

        // 2025-12-19: Picker for browsing shared files
        openPicker,

        // 2025-12-19: Account-level sharing
        findPendingShares,
        fetchLinkedAccountData,
        addTransactionToLinkedAccount,

        // 2025-12-20: Deck sharing
        findPendingDeckShares,

        // 2025-12-20: Vault existence check
        vaultExists,

        // 2025-12-22: Attachment management
        getOrCreateAttachmentsFolder,
        uploadAttachment,
        downloadAttachment,
        getAttachmentInfo,
        deleteAttachment,
        shareAttachmentsFolder
    };
})();
